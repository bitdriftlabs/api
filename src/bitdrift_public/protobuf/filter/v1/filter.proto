// api - bitdrift's client/server API definitions
// Copyright Bitdrift, Inc. All rights reserved.
//
// Use of this source code and APIs are governed by a source available license that can be found in
// the LICENSE file or at:
// https://polyformproject.org/wp-content/uploads/2020/06/PolyForm-Shield-1.0.0.txt

syntax = "proto3";

import "validate/validate.proto";
import "bitdrift_public/protobuf/matcher/v1/log_matcher.proto";

package bitdrift_public.protobuf.filter.v1;

// The configuration of filters that apply transforms to selected logs.
message FiltersConfiguration {
  repeated Filter filters = 1;
}

// Applies configured transform to selected logs.
message Filter {
  // The matcher responsible for selecting logs to apply the filter's transforms to.
  matcher.v1.LogMatcher matcher = 1 [(validate.rules).message = {required: true}];

  // Represents a transform that can be applied to a log in order to modify it.
  message Transform {
    oneof transform_type {
      option (validate.required) = true;
      CaptureFields capture_fields = 1;
      SetField set_field = 2;
      RemoveFields remove_fields = 3;
      ScrubField scrub_field = 4;
    }

    // Captures specified matching field(s). Capturing a field means storing it in a buffer and potentially uploading
    // it to bitdrift remote services. The final decision on whether a field is stored and uploaded depends
    // on various factors, such as buffer and workflow configurations.
    // * If the specified matching field doesn't exist, nothing happens.
    // * If the field exists and has already been captured, nothing happens.
    message CaptureFields {
      // The fields to capture.
      message Fields {
        // A single field.
        message SingleField {
          // The name of the field.
          string name = 1 [(validate.rules).string = {min_len: 1}];
        }

        oneof fields_type {
          option (validate.required) = true;
          SingleField single = 1;
        }
      }

      // The fields to capture.
      Fields fields = 2;
    }

    // Sets the value of a field with a specified name to a given value.
    message SetField {
      enum FieldType {
        UNKNOWN = 0;
        CAPTURED = 1;
        MATCHING_ONLY = 2;
      }

      message SetFieldValue {
        message ExistingField {
          // The name of an existing field.
          string name = 1 [(validate.rules).string = {min_len: 1}];
        }

        oneof value {
          // The constant string value.
          string string_value = 1;
          // The value of an existing field.
          ExistingField existing_field = 2;
        }
      }

      string name = 1 [(validate.rules).string = {min_len: 1}];
      // The value to set the field to.
      SetFieldValue value = 2;
      // The type of the field to set.
      FieldType field_type = 3 [(validate.rules).enum = {defined_only: true not_in: 0}];
      // Whether a transform is allowed to override an existing field. If no and the field already exists,
      // the transform is a no-op.
      bool allow_overriding = 4;
    }

    // Removes a specified field(s).
    message RemoveFields {
      message Fields {
        // A single field.
        message SingleField {
          // The name of the field to remove. If the field doesn't exist, nothing happens. If the field
          // occurs multiple times in the list of log's field - both in captured fields and matching fields -
          // all occurrences of the field are removed.
          string name = 1 [(validate.rules).string = {min_len: 1}];
        }

        oneof fields_type {
          option (validate.required) = true;
          SingleField single = 1;
        }
      }

      // The fields to remove.
      Fields fields = 2;
    }
  }

  // Scrubs the content of a given field, replaces substring(s) matching a given regex with a provided 
  // replacement.
  message ScrubField {
    // The name of the field to scrub. If the field doesn't exist, nothing happens.
    string name = 1 [(validate.rules).string = {min_len: 1}];
    // The regex pattern to match.
    // TODO(Augustyniak): Add more detailed documentation.
    string pattern = 2 [(validate.rules).string = {min_len: 1}];
    // The replacement string.
    string replacement = 3 [(validate.rules).string = {min_len: 1}];
  }

  // The list of transforms to apply to a selected log.
  // Transforms are applied in the specified order.
  repeated Transform transforms = 2 [(validate.rules).repeated = {min_items: 1}];
}
